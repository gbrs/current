#include <iostream>

using namespace std;

int main() {
    int a, b, c, d;
    float e;
    cin >> a >> b >> c >> d;
    cout << a << " " << b << endl;
    return 0;
}

-----------------------------------------

#include <bits/stdc++.h>  // загрузит все библиотеки в компиляторе g++?

-----------------------------------------

if (a > b) {
    ...
}
else {
        cout << "YES";
    }

if (year % 4 == 0 && year % 100 != 0 || mod400)

b = (a > 0) ? 1 : -1;  // тернарный оператор если-то-иначе

a = b - частая ошибка трудноуловимая. True. Компилятор не считает ошибкой.

-----------------------------------------

while (i <= n) {
    ...
    i = i + 1;
}

Цикл с постусловием:
do
    <ваш код>
while (условие);
// единственная конструкция (среди ifов и циклов), которая заканчивается ;

while (cin >> s)   // можно вводить неизвестное количество значений, разделенных пробелом.
В конце зависает в ожидании очередного ввода. Это можно прервать Enter-Ctrl-Z-Enter

-----------------------------------------

for (int i = 1; i <= 100; i++) {
    ...
}

Вечный цикл:
while (true)
for (;;)

-----------------------------------------

int a[n][m];
for (int i = 0; i < n; i++) { //перебор строк
    for (int j = 0; j < m; j++) { //перебор столбцов
        cin >> a[i][j];
    }
}

------------------------------------------

int func(int a, int b, int c, int d) {
    ...
}
...
// в main
func(a, b, c, d);

void F(int I, double D)  // функция F не возвращает никаких значений
int foo(void)  // функция не принимает никаких данных

Передача вектора и переменной по ссылке, а не по значению
func(vector<int>& v, int& x)
... func(vec, y)

-----------------------------------------

#include <vector>

int n;
cin >> n;
vector <int> a(n);
for (int i = 0; i < n; i++) {
    cin >> a[i];
}

for (auto now : a) {}  // перебор всех элементов now массива a

vector <int> a;   // создаст пустой вектор
vector <int> vector_first(5);  // создаст пустой вектор длиной 5, заполненный нулями
vector <char> vector_first(5, ‘!’);  // создаст пустой вектор длиной 5, заполненный “!”

vector < vector <int> > arr(n, vector <int> (m));   двумерный вектор
vector<vector<int>> vec( n , vector<int> (m, 0));   матрица n*m из ноликов

a.push_back(temp);  // аналог append
a.insert(pos, value);
a.pop_back();  // pop
a.erase(p);  // remove
a.size();  // len()
a.empty();  // пуст ли

------------------------------------------

#include <string>

string s;   пустая строка
string s(10, 'x');   строка из 10 иксов
char c;  // похож на массив из получисел-полубукв: ASCI-номера
cin >> s;
c = s[0];
cout << c << s.substr(4, 3);  // с какого и сколько штук

getline(cin, s);  // ввод всей строки в несколько слов с пробелами

for (auto c : s) {}  // перебор всех элементов c строки s

s.rfind();
s.replace( );

------------------------------------------

#include <set>

set <int> s;
s.insert(5);
if (s.count(7)) {}   есть ли семерка во множестве
s.erase(5);
*s.begin()   выведет первый (самый маленький элемент)
*s.rbegin()   выведет последний (самый большой элемент)

for (auto now : s) {}  // перебор всех элементов множества s по возрастанию

#include <set>
multiset<int> ms;
ms.erase(-1);  // удалит все -1
ms.extract(-1);  // удалит только одну из -1
if (ms.find(42) != ms.end())  // нельзя (неэффективно?) проверять вхождение элемента во множестве при помощи ms.count

------------------------------------------

#include <map>

map <int, string> s;
  s[112] = "sos";
  if (s.find(112) != s.end()) {
        cout << "YES\n";
  }

for (auto now : s) {  // перебор всех элементов словаря по возрастанию ключа
    cout << now.first << " " << now.second << "\n";
    // выведет ключ и значение
}

m[42] += 1   сработает даже если ключа 42 в словаре не было

------------------------------------------

Приведение типов
2 / 4 * 3.14 даст 0.0
n / (float) m;  // делаем явное преобразование типов или float(m)
stoi(s)/stof/stod   // преобразуют строки из цифр в целое/флоат/дабл
to_string(число)   // число в строку превратит

Типы данных:
int, long - 4 байтное целое: от -2 147 483 648 до 2 147 483 647.
long long - 8 байтное целое: от -9 223 372 036 854 775 808
до 9 223 372 036 854 775 807 ±(~9 * 10^18)
4 байтный float: ±(3,4⋅10^−38…3,4⋅10^38)
8 байтный double: ±(1,7⋅10^−308…1,7⋅10^308)
bool: true или false, 1 байтный
char, 1 байтный

------------------------------------------

#include <cmath> ...
pow(a,b) степень,
abs(a)/fabs(a),
sqrt(a) корень,
fmod(a, b) остаток от деления вещественных чисел,
exp(a), sin(a), asin(a),
log10(a), log(a) натуральный логарифм
округления:
trunc(x);  отбрасывание; вернет число того же типа, что и переданный аргумент!
floor(x); ceil(x); вниз и вверх к целому числу
round(x); // round(-1.5) -> -2

------------------------------------------

#include <algorithm> ...

min()  // только попарно числа сравнивает
max()

a.end() указывает на элемент сразу после коллекции

sort(a.begin(), a.end());  // сортировка вектора, присваивать ничему не надо
sort(v.rbegin(), v.rend());  // сортировка в обратном порядке
sort(v.begin(), v.end(), [&](int i, int j) {return b[i] < b[j];});  // сортировка массива v по массиву b. [&] все пространство имен будет доступно внутри лямбда функции

reverse(v.begin(), v.end());  // перевернет вектор

find(v.begin(), v.end(), 3) - v.begin();  // найдет индекс первой тройки

upper_bound(v.begin(), v.end(), 7) - v.begin();   бинарный поиск в отсортированном(!) массиве, вернет итератор, указывающий на первый элемент > 7
lower_bound(v.begin(), v.end(), 7) - v.begin();   бинарный поиск первого вхождения числа >= 7
upper_bound(v.begin(), v.end(), 7) - lower_bound(v.begin(), v.end(), 7);   сколько семерок в отсортированном массиве

Операции со множествами:
set_intersection(
            setA.begin(), setA.end(),
            setB.begin(), setB.end(),
            inserter(setC, setC.begin())
    );
есть еще set_union, set_difference, set_symmetric_difference

------------------------------------------

#include <climits> ...
INT_MAX  // самое большое целое
INT_MIN
LLONG_MAX
LLONG_MIN

------------------------------------------

русский язык:
#include <locale> ...
setlocale(LC_ALL, "RUSSIAN");

------------------------------------------

Побитовые операции: << >> & | ^ ~

------------------------------------------

Другие структуры данных:
queue – односторонняя очередь. push() pop() front() back()
deque – двусторонняя очередь. front(); back(); push_back(val); push_front(val); pop_back(); pop_front();
stack - стек. top(); push(val); pop();
pair - пара.
pair <int, double> p;
p = make_pair( 10, 2.22e-1 );
p1.first;
p1.second;  // обращение к элементам пары
vector <pair<<int, double>> v;  // вектор из пар

------------------------------------------

struct House
{
    double height;
    int floors;
    int flats;
};

int main
{
    House h1, h2, h3, h4;  // создали 4 экземпляра структуры House
    h3.height = 10.74;
    h4 = h3;  // значения всех полей h4 будут почленно скопированы в h3
}

Создав вектор из структуры хотим его сортировать по собственным правилам:
bool cmp(man a, man b) {
    return a.height < b.height;
}  // создаем функцию, чтобы сортировать потом именно по росту, по возрастанию
...
sort(a.begin(), a.end(), cmp);

------------------------------------------

Ускорение ввода-вывода:
ios::sync_with_stdio(0);
cin.tie(0);

Чтение файла производить, как будто получаем данные из cin: freopen(“file.txt”, “r”, stdin)
Запись в файл производить, как будто отдаем в cout: freopen(“file.txt”, “w”, stdout)

------------------------------------------

Глобальные переменные создаются над main. Но cin >> делается уже в main.

