-- Дейкстра на списке
#include <vector>
#include <iostream>
#include <map>
#include <algorithm>

int main() {
    int n, na, a, b, con, v;
    int infinite = 200000000;
    std::cin >> n;
    std::vector<std::vector<int>> V(n, std::vector<int>(2));  // исх.данные
    std::vector<int> dist(n, infinite), u(n, 0);
    for (int i = 0; i < n; i++) {
        std::cin >> a >> b;
        V[i][0] = a;
        V[i][1] = b;
    }
    std::cin >> na >> con;
    na -= 1;
    con -= 1;
    dist[na] = 0;
    for (int _ = 0; _ < n; _++) {
        v = -1;
        for (int j = 0; j < n; j++) {
            if (u[j] == 0 && (v == -1 || dist[j] < dist[v])) {
                v = j;
            }
            //std::cout << 1;
        }
        u[v] = 1;
        //std::cout << v + 1 << '\n';
        for (int j = 0; j < n; j++) {
            a = (V[j][0] - V[v][0]) * (V[j][0] - V[v][0]) +
                (V[j][1] - V[v][1]) * (V[j][1] - V[v][1]);
            dist[j] = std::min(dist[j], dist[v] + a);
            //std::cout << 2;
        }
    }
    std::cout << dist[con];
}

/*
3
0 1
0 0
1 3
2 3
*/


-- генерация сочетаний
#include <iostream>
#include <vector>
#include <algorithm>

void Abn(int sm, std::vector<int> &Liste, int v, int &a) {
    std::cout << sm << ' ' << a << '\n';
    int SM;
    if (sm == 0) {
        a += 1;
        return;
    }

    if (sm < 0) {
        return;
    }
    for (int i = 0; i < v; i++) {
        // SM = sm - Liste[i];
        Abn(sm - Liste[i], Liste, i + 1, a);
        // SM = sm;
    }
}

int main() {
    int V, N, a;
    a = 0;
    std::cin >> V >> N;
    std::vector<int> Liste(V);
    for (int i = 0; i < V; i++) {
        std::cin >> Liste[i];
    }
    std::sort(Liste.begin(), Liste.end());
    Abn(N, Liste, V, a);
    std::cout << a;
}



###
vector v(5, vector(5,  vector(5, 1)));
-- с C++17 можно не писать <int>

### for с auto
#include <iostream>
#include <vector>

int main()
{
    using namespace std;

    vector <int> a(5);

    for(auto& now : a) cin >> now;

    for(auto now : a) cout << now << " ";

    return 0;
}


#1.3
#include <iostream>
#include <vector>

int main() {
    int n, L = 0, R = 1, mx, l = 0, r = 1, a;
    std::cin >> n;
    std::vector<int> Liste_sum(n + 1);

    for (int i = 1; i <= n; i++) {
        std::cin >> a;
        Liste_sum[i] = Liste_sum[i - 1] + a;
    }

    mx = Liste_sum[R] - Liste_sum[L];

    for (int i = 1; i <= n; i++) {
        if (Liste_sum[i] < Liste_sum[L]) {
            if (Liste_sum[R] - Liste_sum[L] > mx) {
                mx = Liste_sum[R] - Liste_sum[L];
                l = L;
                r = R;
            }
            L = i;
            R = i;
            //std::cout << L << ' ' << R << ' ' << mx << '\n';
            continue;
        }
        if (Liste_sum[i] > Liste_sum[R]) {
            R = i;
            if (Liste_sum[R] - Liste_sum[L] > mx) {
                mx = Liste_sum[R] - Liste_sum[L];
                l = L;
                r = R;
            }
        }
        //std::cout << L << ' ' << R << ' ' << mx << '\n';
    }
    std::cout << l + 1 << ' ' << r << ' ' << mx;
}

=>

-- переусложнил логику программы (ифы в ифах...), сам запутался. Надо было всего 2 ифа.
-- четко представлять логику кода.
#include <iostream>
#include <vector>

int main() {
    int n, L = 0, mx, l = 0, r = 1, a;
    std::cin >> n;
    std::vector<int> Liste_sum(n + 1);

    for (int i = 1; i <= n; i++) {
        std::cin >> a;
        Liste_sum[i] = Liste_sum[i - 1] + a;
    }

    mx = Liste_sum[r] - Liste_sum[l];

    for (int i = 1; i <= n; i++) {
        if (Liste_sum[i] < Liste_sum[L]) {
            L = i;
            // std::cout << L << ' ' << i << ' ' << mx << '\n';
            continue;
        }
        if (Liste_sum[i] - Liste_sum[L] > mx) {
            mx = Liste_sum[i] - Liste_sum[L];
            l = L;
            r = i;
        }
        // std::cout << L << ' ' << i << ' ' << mx << '\n';
    }
    std::cout << l + 1 << ' ' << r << ' ' << mx;
}

-- увеличенный массив + сортировка + елочка

#include <iostream>
#include <vector>
#include <set>
#include <algorithm>


int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    long long w, h, n, m, k, kkk, n_ur, m_ur, a, start_col, len, flag = 0, kk = 0;
    std::cin >> w >> h >> n >> m >> k;
    n += 1;
    m += 1;
    kkk = k + 600000;
    std::vector<long long> nn(n), mm(m), grafstva(kkk);
    if (n != 1) {
        n_ur = 0;
        for (int i = 0; i < n - 1; i++) {
            std::cin >> nn[i];
            a = nn[i];
            nn[i] -= n_ur;
            n_ur = a;
        }
        nn[n - 1] = w - n_ur;
    } else {
        nn[0] = w;
    }
    if (m != 1) {
        m_ur = 0;
        for (int i = 0; i < m - 1; i++) {
            std::cin >> mm[i];
            a = mm[i];
            mm[i] -= m_ur;
            m_ur = a;
        }
        mm[m - 1] = h - m_ur;
    } else {
        mm[0] = h;
    }
    sort(nn.rbegin(), nn.rend());
    sort(mm.rbegin(), mm.rend());

    for (int diag = 0; diag < std::min(m, n); diag++) {
        for (int i = diag; i < n; i++) {
            if (flag == 0 && kk < kkk) {
                grafstva[kk] = nn[i] * mm[diag];
                kk++;
                if (kk == kkk) {
                    sort(grafstva.rbegin(), grafstva.rend());
                    flag = 1;
                    kk = k;
                }
            } else {
                if (kk < kkk) {
                    a = nn[i] * mm[diag];
                    if (a > grafstva[k - 1]) {
                        grafstva[kk] = a;
                        kk++;
                    }
                    if (kk == kkk) {
                        sort(grafstva.rbegin(), grafstva.rend());
                        kk = k;
                    }
                }
            }
        }
        for (int j = diag + 1; j < m; j++) {
            if (flag == 0 && kk < kkk) {
                grafstva[kk] = nn[diag] * mm[j];
                kk++;
                if (kk == kkk) {
                    sort(grafstva.rbegin(), grafstva.rend());
                    flag = 1;
                    kk = k;
                }
            } else {
                if (kk < kkk) {
                    a = nn[diag] * mm[j];
                    if (a > grafstva[k - 1]) {
                        grafstva[kk] = a;
                        kk++;
                    }
                    if (kk == kkk) {
                        sort(grafstva.rbegin(), grafstva.rend());
                        kk = k;
                    }
                }
            }
        }
    }
    sort(grafstva.rend() - kk, grafstva.rend());
    std::cout << grafstva[k - 1] << " " << grafstva[0];
}


-- увеличенный массив + сортировка

#include <iostream>
#include <vector>
#include <algorithm>


int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    long long w, h, n, m, k, kk, kkk, flag, n_ur, m_ur, a;
    std::cin >> w >> h >> n >> m >> k;
    n += 1;
    m += 1;
    kkk = k + 900000;
    std::vector<long long> nn(n), mm(m), grafstva(kkk);
    if (n != 1) {
        n_ur = 0;
        for (int i = 0; i < n - 1; i++) {
            std::cin >> nn[i];
            a = nn[i];
            nn[i] -= n_ur;
            n_ur = a;
        }
        nn[n - 1] = w - n_ur;
    } else {
        nn[0] = w;
    }
    if (m != 1) {
        m_ur = 0;
        for (int i = 0; i < m - 1; i++) {
            std::cin >> mm[i];
            a = mm[i];
            mm[i] -= m_ur;
            m_ur = a;
        }
        mm[m - 1] = h - m_ur;
    } else {
        mm[0] = h;
    }

    sort(nn.rbegin(), nn.rend());
    sort(mm.rbegin(), mm.rend());

    kk = 0;
    flag = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (flag == 0 && kk < kkk) {
                grafstva[kk] = nn[i] * mm[j];
                kk++;
                if (kk == kkk) {
                    sort(grafstva.rbegin(), grafstva.rend());
                    flag = 1;
                    kk = k;
                }
            } else {
                if (kk < kkk) {
                    a = nn[i] * mm[j];
                    if (a > grafstva[k - 1]) {
                        grafstva[kk] = a;
                        kk++;
                    }
                    if (kk == kkk) {
                        sort(grafstva.rbegin(), grafstva.rend());
                        kk = k;
                    }
                }
            }


        }
    }
    sort(grafstva.rend() - kk, grafstva.rend());
    std::cout << grafstva[k - 1] << " " << grafstva[0];
}


-- проход елочкой

#include <iostream>
#include <vector>
#include <set>
#include <algorithm>


int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    long long w, h, n, m, k, n_ur, m_ur, a, start_col, len, flag = 0;
    std::cin >> w >> h >> n >> m >> k;
    n += 1;
    m += 1;
    std::vector<long long> nn(n), mm(m);
    std::multiset<long long> grafstva;
    if (n != 1) {
        n_ur = 0;
        for (int i = 0; i < n - 1; i++) {
            std::cin >> nn[i];
            a = nn[i];
            nn[i] -= n_ur;
            n_ur = a;
        }
        nn[n - 1] = w - n_ur;
    } else {
        nn[0] = w;
    }
    if (m != 1) {
        m_ur = 0;
        for (int i = 0; i < m - 1; i++) {
            std::cin >> mm[i];
            a = mm[i];
            mm[i] -= m_ur;
            m_ur = a;
        }
        mm[m - 1] = h - m_ur;
    } else {
        mm[0] = h;
    }
    sort(nn.rbegin(), nn.rend());
    sort(mm.rbegin(), mm.rend());

    for (int diag = 0; diag < std::min(m, n); diag++) {
        for (int i = diag; i < n; i++) {
            a = nn[i] * mm[diag];
            if (grafstva.size() < k) {
                grafstva.insert(a);
            } else {
                if (a > *grafstva.begin()) {
                    // std::cout << *grafstva.begin() << " ";
                    grafstva.extract(*grafstva.begin());
                    grafstva.insert(a);
                    // std::cout << nn[i] * mm[j] << " ";
                } else {
                    n = i;
                    break;
                }
            }
        }
        for (int j = diag + 1; j < m; j++) {
            a = nn[diag] * mm[j];
            if (grafstva.size() < k) {
                grafstva.insert(a);
            } else {
                if (a > *grafstva.begin()) {
                    // std::cout << *grafstva.begin() << " ";
                    grafstva.extract(*grafstva.begin());
                    grafstva.insert(a);
                    // std::cout << nn[i] * mm[j] << " ";
                } else {
                    m = j;
                    break;
                }
            }
        }
    }

    std::cout << *grafstva.begin() << " " << *grafstva.rbegin();
}

-------------------------------------------

-- проход диагоналями

#include <iostream>
#include <vector>
#include <set>
#include <algorithm>


int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    long long w, h, n, m, k, n_ur, m_ur, a, start_col, len, flag = 0;
    std::cin >> w >> h >> n >> m >> k;
    n += 1;
    m += 1;
    std::vector<long long> nn(n), mm(m);
    std::multiset<long long> grafstva;
    if (n != 1) {
        n_ur = 0;
        for (int i = 0; i < n - 1; i++) {
            std::cin >> nn[i];
            a = nn[i];
            nn[i] -= n_ur;
            n_ur = a;
        }
        nn[n - 1] = w - n_ur;
    } else {
        nn[0] = w;
    }
    if (m != 1) {
        m_ur = 0;
        for (int i = 0; i < m - 1; i++) {
            std::cin >> mm[i];
            a = mm[i];
            mm[i] -= m_ur;
            m_ur = a;
        }
        mm[m - 1] = h - m_ur;
    } else {
        mm[0] = h;
    }
    sort(nn.rbegin(), nn.rend());
    sort(mm.rbegin(), mm.rend());

    for (long long diag = 1; diag < n + m; diag++) {
        start_col = std::max((long long) 0, diag - n);
        len = std::min(diag, std::min(m - start_col, n));
        for (int j = 0; j < len; j++) {
            a = nn[std::min(n, diag) - j - 1] * mm[start_col + j];
            // std::cout << a << '\n';
            if (grafstva.size() < k) {
                grafstva.insert(a);
            } else {
                if (a > *grafstva.begin()) {
                    // std::cout << *grafstva.begin() << " ";
                    grafstva.extract(*grafstva.begin());
                    grafstva.insert(a);
                    // std::cout << nn[i] * mm[j] << " ";
                }
            }
        }
    }

    std::cout << *grafstva.begin() << " " << *grafstva.rbegin();
}

------------------------------------------

#include <iostream> 
#include <vector> 
#include <set> 
#include <algorithm> 


int main() { 
    std::ios::sync_with_stdio(0); 
    std::cin.tie(0); 
    long long w, h, n, m, k, n_ur, m_ur, a, flag = 0; 
    std::cin >> w >> h >> n >> m >> k; 
    n += 1; 
    m += 1; 
    std::vector<long long> nn(n), mm(m); 
    std::multiset<long long> grafstva; 
    if (n != 1) { 
        n_ur = 0; 
        for (int i = 0; i < n - 1; i++) { 
            std::cin >> nn[i]; 
            a = nn[i]; 
            nn[i] -= n_ur; 
            n_ur = a; 
        } 
        nn[n - 1] = w - n_ur; 
    } else { 
        nn[0] = w; 
    } 
    if (m != 1) { 
        m_ur = 0; 
        for (int i = 0; i < m - 1; i++) { 
            std::cin >> mm[i]; 
            a = mm[i]; 
            mm[i] -= m_ur; 
            m_ur = a; 
        } 
        mm[m - 1] = h - m_ur; 
    } else { 
        mm[0] = h; 
    } 
    sort(nn.rbegin(), nn.rend()); 
    sort(mm.rbegin(), mm.rend()); 
    // std::cout << std::min(k / m + 1, n) << ' ' << std::min(k / n + 1, m) << '\n';
    for (int i = 0; i < std::min(k / m + 1, n); i++) { 
        for (int j = 0; j < std::min(k / n + 1, m); j++) { 
            if (i * std::min(k / n + 1, m) + j < k) {
                // std::cout << "+ ";
                grafstva.insert(nn[i] * mm[j]); 
            } else { 
                if (nn[i] * mm[j] > *grafstva.begin()) { 
                    // std::cout << " -+";
                    // std::cout << *grafstva.begin() << " "; 
                    grafstva.extract(*grafstva.begin()); 
                    grafstva.insert(nn[i] * mm[j]); 
                    // std::cout << nn[i] * mm[j] << " "; 
                }
            } 
        } 
    } 
    
    // std::cout << '\n';
    
    for (int i = 0; i < std::min(k / m + 1, n); i++) { 
        for (int j = std::min(k / n + 1, m); j < m; j++) { 
            if (nn[i] * mm[j] > *grafstva.begin()) { 
                grafstva.extract(*grafstva.begin()); 
                grafstva.insert(nn[i] * mm[j]); 
            } else { 
                break; 
            } 
        } 
    } 
    
    for (int i = std::min(k / m + 1, n); i < n; i++) { 
        for (int j = 0; j < m; j++) { 
            if (nn[i] * mm[j] > *grafstva.begin()) { 
                // std::cout << *grafstva.begin() << " "; 
                grafstva.extract(*grafstva.begin()); 
                grafstva.insert(nn[i] * mm[j]); 
                // std::cout << nn[i] * mm[j] << " "; 
            } else { 
                if (j == 0) { 
                    flag = 1; 
                } 
                break; 
            } 
        } 
        if (flag == 1) { 
            break; 
        } 
    } 
    
    std::cout << '\n'; 
    std::cout << *grafstva.begin() << " " << *grafstva.rbegin(); 
}


-- дерево отрезков сумма на разностном массиве
-- ошибка выполнения на задаче 5
/*
Реализуйте эффективную структуру данных для хранения элементов
и увеличения нескольких подряд идущих элементов на одно и то же число.
*/
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> v(10000), raznost(100000), tree(400000, 0);
// вектор исходных данных, разностный массив, и под дерево отрезков

void build(int a, int tl, int tr) {
    if (tl == tr) {
        tree[a] = raznost[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a * 2, tl, tm);
        build(a * 2 + 1, tm + 1, tr);
        tree[a] = tree[a * 2] + tree[a * 2 + 1];
    }
}

void update(int l, int r, int c, int tl, int tr) {
    raznost[l - 1] += c;
    raznost[r] -= c;
    build(1, tl, tr);  // грубо перестраиваю все дерево, а не только то, что надо
    /*
    // не одолел правильный апдейт
    if (tl == tr) {
        if (tl == l) {
            tree[l] += c;
        } else {
            if (tr == r + 1) {
                tree[r + 1] -= c;
            }
        }
    } else {
        int tm = (tl + tr) / 2;
        update(a * 2, tl, tm);
        update(a * 2 + 1, tm + 1, tr);
        tree[a] = tree[a * 2] + tree[a * 2 + 1];
    }
    */
}

int summ(int a, int tl, int tr, int l, int r) {
    if (r < tl || l > tr)
        return 0;
    if (l <= tl && tr <= r)
        return tree[a];
    int tm = (tl + tr) / 2;
    return summ(a * 2, tl, tm, l, r) + summ(a * 2 + 1, tm + 1, tr, l, r);
}

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    int n, k, a, b, c, otv;
    char t;
    std::cin >> n;

    // стоило раскладывать сразу с индекса 1?
    for (int i = 0; i < n; i++) {
        std::cin >> v[i];
    }

    // по-моему, не нужный кусок
    for (int i = 0; i < n; i++) {
        raznost[i] = v[i];
    }

    // создаем разностный массив
    raznost[0] = v[0];
    for (int i = 1; i < n; i++) {
        raznost[i] = v[i] - v[i - 1];
    }

    build(1, 0, n - 1);  // строим дерево

    // выполняем k запросов
    std::cin >> k;
    for (int i = 0; i < k; i++) {
        std::cin >> t;
        if (t == 'g') {
            // запрос числа на b-м месте
            std::cin >> b;
            otv = summ(1, 0, n - 1, 1 - 1, b - 1); // сумма от первого элемента до i-го и есть искомое
            std::cout << otv << '\n';
        } else {
            // добавление числа c на отрезке [a, b]
            std::cin >> a >> b >> c;
            update(a, b, c, 0, n - 1);
        }
    }

/*
5
7 3 1 6 4
5
g 5
g 4
g 3
a 2 4 4
g 4

4
6
1
10
*/
}


-- Знакопеременная сумма на отрезке
-- ошибка выполнения на 9-м
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> v(10000), tree(400000, 0);

void build(int a, int tl, int tr) {
    if (tl == tr) {
        tree[a] = v[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a * 2, tl, tm);
        build(a * 2 + 1, tm + 1, tr);
        tree[a] = tree[a * 2] + tree[a * 2 + 1];
    }
}

void update(int a, int b, int tl, int tr) {
    v[a] = b;
    build(1, tl, tr);  // неправильно грубо перестраиваю дерево отрезков каждый раз
}

int summ(int a, int tl, int tr, int l, int r) {
    if (r < tl || l > tr)
        return 0;
    if (l <= tl && tr <= r)
        return tree[a];
    int tm = (tl + tr) / 2;
    return summ(a * 2, tl, tm, l, r) + summ(a * 2 + 1, tm + 1, tr, l, r);
}

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    int n, k, a, b, c, otv;
    std::cin >> n;

    // ввод исходных данных, умножая каждый четный элемент на -1
    for (int i = 0; i < n; i++) {
        if (i % 2 == 0) {
            std::cin >> v[i];
        } else {
            std::cin >> c;
            v[i] = -1 * c;
        }
    }

    build(1, 0, n - 1);

    // выполняем запросы
    // если меняем четный элемент, не забывать на -1 умножить
    // и если сумма элементов, начиная с четного элемента, то умножаем полученное на -1
    std::cin >> k;
    for (int i = 0; i < k; i++) {
        std::cin >> c;
        if (c == 1) {
            std::cin >> a >> b;
            otv = summ(1, 0, n - 1, a - 1, b - 1);
            if (a % 2 == 1) {
                std::cout << otv << '\n';
            } else {
                std::cout << -1 * otv << '\n';
            }
        } else {
            std::cin >> a >> b;
            if (a % 2 == 1) {
                update(a - 1, b, 0, n - 1);
            } else {
                update(a - 1, -1 * b, 0, n - 1);
            }
        }
    }
}

-- вариант с попыткой правильного апдейта
-- неправильный ответ уже на третьем тесте
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> v(10000), tree(400000, 0);

void build(int a, int tl, int tr) {
    if (tl == tr) {
        tree[a] = v[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a * 2, tl, tm);
        build(a * 2 + 1, tm + 1, tr);
        tree[a] = tree[a * 2] + tree[a * 2 + 1];
    }
}

void update(int a, int b, int c, int tl, int tr) {
    // попытка сделать правильный вариант апдейта
    if (tl == tr) {
        tree[a] = c;
    } else {
        int tm = (tl + tr) / 2;
        if (b <= tm) {
            update (a * 2, b, c, tl, tm);
        } else {
            update (a * 2 + 1, b, c, tm + 1, tr);
        }
        tree[a] = tree[a * 2] + tree[a * 2 + 1];
    }
}

int summ(int a, int tl, int tr, int l, int r) {
    if (r < tl || l > tr)
        return 0;
    if (l <= tl && tr <= r)
        return tree[a];
    int tm = (tl + tr) / 2;
    return summ(a * 2, tl, tm, l, r) + summ(a * 2 + 1, tm + 1, tr, l, r);
}

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    int n, k, a, b, c, otv;
    std::cin >> n;

    for (int i = 0; i < n; i++) {
        if (i % 2 == 0) {
            std::cin >> v[i];
        } else {
            std::cin >> c;
            v[i] = -1 * c;
        }
    }

    build(1, 0, n - 1);

    // выполняем запросы
    std::cin >> k;
    for (int i = 0; i < k; i++) {
        std::cin >> c;
        if (c == 1) {
            std::cin >> a >> b;
            otv = summ(1, 0, n - 1, a - 1, b - 1);
            if (a % 2 == 1) {
                std::cout << otv << '\n';
            } else {
                std::cout << -1 * otv << '\n';
            }
        } else {
            std::cin >> a >> b;
            if (a % 2 == 1) {
                update(a - 1, a - 1, b, 0, n - 1);
            } else {
                update(a - 1, a - 1, -1 * b, 0, n - 1);
            }
        }
    }
}
