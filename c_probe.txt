-- Дейкстра на списке
#include <vector>
#include <iostream>
#include <map>
#include <algorithm>

int main() {
    int n, na, a, b, con, v;
    int infinite = 200000000;
    std::cin >> n;
    std::vector<std::vector<int>> V(n, std::vector<int>(2));  // исх.данные
    std::vector<int> dist(n, infinite), u(n, 0);
    for (int i = 0; i < n; i++) {
        std::cin >> a >> b;
        V[i][0] = a;
        V[i][1] = b;
    }
    std::cin >> na >> con;
    na -= 1;
    con -= 1;
    dist[na] = 0;
    for (int _ = 0; _ < n; _++) {
        v = -1;
        for (int j = 0; j < n; j++) {
            if (u[j] == 0 && (v == -1 || dist[j] < dist[v])) {
                v = j;
            }
            //std::cout << 1;
        }
        u[v] = 1;
        //std::cout << v + 1 << '\n';
        for (int j = 0; j < n; j++) {
            a = (V[j][0] - V[v][0]) * (V[j][0] - V[v][0]) +
                (V[j][1] - V[v][1]) * (V[j][1] - V[v][1]);
            dist[j] = std::min(dist[j], dist[v] + a);
            //std::cout << 2;
        }
    }
    std::cout << dist[con];
}

/*
3
0 1
0 0
1 3
2 3
*/


-- генерация сочетаний
#include <iostream>
#include <vector>
#include <algorithm>

void Abn(int sm, std::vector<int> &Liste, int v, int &a) {
    std::cout << sm << ' ' << a << '\n';
    int SM;
    if (sm == 0) {
        a += 1;
        return;
    }

    if (sm < 0) {
        return;
    }
    for (int i = 0; i < v; i++) {
        // SM = sm - Liste[i];
        Abn(sm - Liste[i], Liste, i + 1, a);
        // SM = sm;
    }
}

int main() {
    int V, N, a;
    a = 0;
    std::cin >> V >> N;
    std::vector<int> Liste(V);
    for (int i = 0; i < V; i++) {
        std::cin >> Liste[i];
    }
    std::sort(Liste.begin(), Liste.end());
    Abn(N, Liste, V, a);
    std::cout << a;
}



###
vector v(5, vector(5,  vector(5, 1)));
-- с C++17 можно не писать <int>

### for с auto
#include <iostream>
#include <vector>

int main()
{
    using namespace std;

    vector <int> a(5);

    for(auto& now : a) cin >> now;

    for(auto now : a) cout << now << " ";

    return 0;
}


#1.3
#include <iostream>
#include <vector>

int main() {
    int n, L = 0, R = 1, mx, l = 0, r = 1, a;
    std::cin >> n;
    std::vector<int> Liste_sum(n + 1);

    for (int i = 1; i <= n; i++) {
        std::cin >> a;
        Liste_sum[i] = Liste_sum[i - 1] + a;
    }

    mx = Liste_sum[R] - Liste_sum[L];

    for (int i = 1; i <= n; i++) {
        if (Liste_sum[i] < Liste_sum[L]) {
            if (Liste_sum[R] - Liste_sum[L] > mx) {
                mx = Liste_sum[R] - Liste_sum[L];
                l = L;
                r = R;
            }
            L = i;
            R = i;
            //std::cout << L << ' ' << R << ' ' << mx << '\n';
            continue;
        }
        if (Liste_sum[i] > Liste_sum[R]) {
            R = i;
            if (Liste_sum[R] - Liste_sum[L] > mx) {
                mx = Liste_sum[R] - Liste_sum[L];
                l = L;
                r = R;
            }
        }
        //std::cout << L << ' ' << R << ' ' << mx << '\n';
    }
    std::cout << l + 1 << ' ' << r << ' ' << mx;
}

=>

-- переусложнил логику программы (ифы в ифах...), сам запутался. Надо было всего 2 ифа.
-- четко представлять логику кода.
#include <iostream>
#include <vector>

int main() {
    int n, L = 0, mx, l = 0, r = 1, a;
    std::cin >> n;
    std::vector<int> Liste_sum(n + 1);

    for (int i = 1; i <= n; i++) {
        std::cin >> a;
        Liste_sum[i] = Liste_sum[i - 1] + a;
    }

    mx = Liste_sum[r] - Liste_sum[l];

    for (int i = 1; i <= n; i++) {
        if (Liste_sum[i] < Liste_sum[L]) {
            L = i;
            // std::cout << L << ' ' << i << ' ' << mx << '\n';
            continue;
        }
        if (Liste_sum[i] - Liste_sum[L] > mx) {
            mx = Liste_sum[i] - Liste_sum[L];
            l = L;
            r = i;
        }
        // std::cout << L << ' ' << i << ' ' << mx << '\n';
    }
    std::cout << l + 1 << ' ' << r << ' ' << mx;
}

-- увеличенный массив + сортировка + елочка

#include <iostream>
#include <vector>
#include <set>
#include <algorithm>


int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    long long w, h, n, m, k, kkk, n_ur, m_ur, a, start_col, len, flag = 0, kk = 0;
    std::cin >> w >> h >> n >> m >> k;
    n += 1;
    m += 1;
    kkk = k + 600000;
    std::vector<long long> nn(n), mm(m), grafstva(kkk);
    if (n != 1) {
        n_ur = 0;
        for (int i = 0; i < n - 1; i++) {
            std::cin >> nn[i];
            a = nn[i];
            nn[i] -= n_ur;
            n_ur = a;
        }
        nn[n - 1] = w - n_ur;
    } else {
        nn[0] = w;
    }
    if (m != 1) {
        m_ur = 0;
        for (int i = 0; i < m - 1; i++) {
            std::cin >> mm[i];
            a = mm[i];
            mm[i] -= m_ur;
            m_ur = a;
        }
        mm[m - 1] = h - m_ur;
    } else {
        mm[0] = h;
    }
    sort(nn.rbegin(), nn.rend());
    sort(mm.rbegin(), mm.rend());

    for (int diag = 0; diag < std::min(m, n); diag++) {
        for (int i = diag; i < n; i++) {
            if (flag == 0 && kk < kkk) {
                grafstva[kk] = nn[i] * mm[diag];
                kk++;
                if (kk == kkk) {
                    sort(grafstva.rbegin(), grafstva.rend());
                    flag = 1;
                    kk = k;
                }
            } else {
                if (kk < kkk) {
                    a = nn[i] * mm[diag];
                    if (a > grafstva[k - 1]) {
                        grafstva[kk] = a;
                        kk++;
                    }
                    if (kk == kkk) {
                        sort(grafstva.rbegin(), grafstva.rend());
                        kk = k;
                    }
                }
            }
        }
        for (int j = diag + 1; j < m; j++) {
            if (flag == 0 && kk < kkk) {
                grafstva[kk] = nn[diag] * mm[j];
                kk++;
                if (kk == kkk) {
                    sort(grafstva.rbegin(), grafstva.rend());
                    flag = 1;
                    kk = k;
                }
            } else {
                if (kk < kkk) {
                    a = nn[diag] * mm[j];
                    if (a > grafstva[k - 1]) {
                        grafstva[kk] = a;
                        kk++;
                    }
                    if (kk == kkk) {
                        sort(grafstva.rbegin(), grafstva.rend());
                        kk = k;
                    }
                }
            }
        }
    }
    sort(grafstva.rend() - kk, grafstva.rend());
    std::cout << grafstva[k - 1] << " " << grafstva[0];
}


-- увеличенный массив + сортировка

#include <iostream>
#include <vector>
#include <algorithm>


int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    long long w, h, n, m, k, kk, kkk, flag, n_ur, m_ur, a;
    std::cin >> w >> h >> n >> m >> k;
    n += 1;
    m += 1;
    kkk = k + 900000;
    std::vector<long long> nn(n), mm(m), grafstva(kkk);
    if (n != 1) {
        n_ur = 0;
        for (int i = 0; i < n - 1; i++) {
            std::cin >> nn[i];
            a = nn[i];
            nn[i] -= n_ur;
            n_ur = a;
        }
        nn[n - 1] = w - n_ur;
    } else {
        nn[0] = w;
    }
    if (m != 1) {
        m_ur = 0;
        for (int i = 0; i < m - 1; i++) {
            std::cin >> mm[i];
            a = mm[i];
            mm[i] -= m_ur;
            m_ur = a;
        }
        mm[m - 1] = h - m_ur;
    } else {
        mm[0] = h;
    }

    sort(nn.rbegin(), nn.rend());
    sort(mm.rbegin(), mm.rend());

    kk = 0;
    flag = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (flag == 0 && kk < kkk) {
                grafstva[kk] = nn[i] * mm[j];
                kk++;
                if (kk == kkk) {
                    sort(grafstva.rbegin(), grafstva.rend());
                    flag = 1;
                    kk = k;
                }
            } else {
                if (kk < kkk) {
                    a = nn[i] * mm[j];
                    if (a > grafstva[k - 1]) {
                        grafstva[kk] = a;
                        kk++;
                    }
                    if (kk == kkk) {
                        sort(grafstva.rbegin(), grafstva.rend());
                        kk = k;
                    }
                }
            }


        }
    }
    sort(grafstva.rend() - kk, grafstva.rend());
    std::cout << grafstva[k - 1] << " " << grafstva[0];
}


-- проход елочкой

#include <iostream>
#include <vector>
#include <set>
#include <algorithm>


int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    long long w, h, n, m, k, n_ur, m_ur, a, start_col, len, flag = 0;
    std::cin >> w >> h >> n >> m >> k;
    n += 1;
    m += 1;
    std::vector<long long> nn(n), mm(m);
    std::multiset<long long> grafstva;
    if (n != 1) {
        n_ur = 0;
        for (int i = 0; i < n - 1; i++) {
            std::cin >> nn[i];
            a = nn[i];
            nn[i] -= n_ur;
            n_ur = a;
        }
        nn[n - 1] = w - n_ur;
    } else {
        nn[0] = w;
    }
    if (m != 1) {
        m_ur = 0;
        for (int i = 0; i < m - 1; i++) {
            std::cin >> mm[i];
            a = mm[i];
            mm[i] -= m_ur;
            m_ur = a;
        }
        mm[m - 1] = h - m_ur;
    } else {
        mm[0] = h;
    }
    sort(nn.rbegin(), nn.rend());
    sort(mm.rbegin(), mm.rend());

    for (int diag = 0; diag < std::min(m, n); diag++) {
        for (int i = diag; i < n; i++) {
            a = nn[i] * mm[diag];
            if (grafstva.size() < k) {
                grafstva.insert(a);
            } else {
                if (a > *grafstva.begin()) {
                    // std::cout << *grafstva.begin() << " ";
                    grafstva.extract(*grafstva.begin());
                    grafstva.insert(a);
                    // std::cout << nn[i] * mm[j] << " ";
                } else {
                    n = i;
                    break;
                }
            }
        }
        for (int j = diag + 1; j < m; j++) {
            a = nn[diag] * mm[j];
            if (grafstva.size() < k) {
                grafstva.insert(a);
            } else {
                if (a > *grafstva.begin()) {
                    // std::cout << *grafstva.begin() << " ";
                    grafstva.extract(*grafstva.begin());
                    grafstva.insert(a);
                    // std::cout << nn[i] * mm[j] << " ";
                } else {
                    m = j;
                    break;
                }
            }
        }
    }

    std::cout << *grafstva.begin() << " " << *grafstva.rbegin();
}

-------------------------------------------

-- проход диагоналями

#include <iostream>
#include <vector>
#include <set>
#include <algorithm>


int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    long long w, h, n, m, k, n_ur, m_ur, a, start_col, len, flag = 0;
    std::cin >> w >> h >> n >> m >> k;
    n += 1;
    m += 1;
    std::vector<long long> nn(n), mm(m);
    std::multiset<long long> grafstva;
    if (n != 1) {
        n_ur = 0;
        for (int i = 0; i < n - 1; i++) {
            std::cin >> nn[i];
            a = nn[i];
            nn[i] -= n_ur;
            n_ur = a;
        }
        nn[n - 1] = w - n_ur;
    } else {
        nn[0] = w;
    }
    if (m != 1) {
        m_ur = 0;
        for (int i = 0; i < m - 1; i++) {
            std::cin >> mm[i];
            a = mm[i];
            mm[i] -= m_ur;
            m_ur = a;
        }
        mm[m - 1] = h - m_ur;
    } else {
        mm[0] = h;
    }
    sort(nn.rbegin(), nn.rend());
    sort(mm.rbegin(), mm.rend());

    for (long long diag = 1; diag < n + m; diag++) {
        start_col = std::max((long long) 0, diag - n);
        len = std::min(diag, std::min(m - start_col, n));
        for (int j = 0; j < len; j++) {
            a = nn[std::min(n, diag) - j - 1] * mm[start_col + j];
            // std::cout << a << '\n';
            if (grafstva.size() < k) {
                grafstva.insert(a);
            } else {
                if (a > *grafstva.begin()) {
                    // std::cout << *grafstva.begin() << " ";
                    grafstva.extract(*grafstva.begin());
                    grafstva.insert(a);
                    // std::cout << nn[i] * mm[j] << " ";
                }
            }
        }
    }

    std::cout << *grafstva.begin() << " " << *grafstva.rbegin();
}

------------------------------------------

#include <iostream> 
#include <vector> 
#include <set> 
#include <algorithm> 


int main() { 
    std::ios::sync_with_stdio(0); 
    std::cin.tie(0); 
    long long w, h, n, m, k, n_ur, m_ur, a, flag = 0; 
    std::cin >> w >> h >> n >> m >> k; 
    n += 1; 
    m += 1; 
    std::vector<long long> nn(n), mm(m); 
    std::multiset<long long> grafstva; 
    if (n != 1) { 
        n_ur = 0; 
        for (int i = 0; i < n - 1; i++) { 
            std::cin >> nn[i]; 
            a = nn[i]; 
            nn[i] -= n_ur; 
            n_ur = a; 
        } 
        nn[n - 1] = w - n_ur; 
    } else { 
        nn[0] = w; 
    } 
    if (m != 1) { 
        m_ur = 0; 
        for (int i = 0; i < m - 1; i++) { 
            std::cin >> mm[i]; 
            a = mm[i]; 
            mm[i] -= m_ur; 
            m_ur = a; 
        } 
        mm[m - 1] = h - m_ur; 
    } else { 
        mm[0] = h; 
    } 
    sort(nn.rbegin(), nn.rend()); 
    sort(mm.rbegin(), mm.rend()); 
    // std::cout << std::min(k / m + 1, n) << ' ' << std::min(k / n + 1, m) << '\n';
    for (int i = 0; i < std::min(k / m + 1, n); i++) { 
        for (int j = 0; j < std::min(k / n + 1, m); j++) { 
            if (i * std::min(k / n + 1, m) + j < k) {
                // std::cout << "+ ";
                grafstva.insert(nn[i] * mm[j]); 
            } else { 
                if (nn[i] * mm[j] > *grafstva.begin()) { 
                    // std::cout << " -+";
                    // std::cout << *grafstva.begin() << " "; 
                    grafstva.extract(*grafstva.begin()); 
                    grafstva.insert(nn[i] * mm[j]); 
                    // std::cout << nn[i] * mm[j] << " "; 
                }
            } 
        } 
    } 
    
    // std::cout << '\n';
    
    for (int i = 0; i < std::min(k / m + 1, n); i++) { 
        for (int j = std::min(k / n + 1, m); j < m; j++) { 
            if (nn[i] * mm[j] > *grafstva.begin()) { 
                grafstva.extract(*grafstva.begin()); 
                grafstva.insert(nn[i] * mm[j]); 
            } else { 
                break; 
            } 
        } 
    } 
    
    for (int i = std::min(k / m + 1, n); i < n; i++) { 
        for (int j = 0; j < m; j++) { 
            if (nn[i] * mm[j] > *grafstva.begin()) { 
                // std::cout << *grafstva.begin() << " "; 
                grafstva.extract(*grafstva.begin()); 
                grafstva.insert(nn[i] * mm[j]); 
                // std::cout << nn[i] * mm[j] << " "; 
            } else { 
                if (j == 0) { 
                    flag = 1; 
                } 
                break; 
            } 
        } 
        if (flag == 1) { 
            break; 
        } 
    } 
    
    std::cout << '\n'; 
    std::cout << *grafstva.begin() << " " << *grafstva.rbegin(); 
}


-- дерево отрезков сумма на разностном массиве
-- ошибка выполнения на задаче 5
/*
Реализуйте эффективную структуру данных для хранения элементов
и увеличения нескольких подряд идущих элементов на одно и то же число.
*/
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> v(10000), raznost(100000), tree(400000, 0);
// вектор исходных данных, разностный массив, и под дерево отрезков

void build(int a, int tl, int tr) {
    if (tl == tr) {
        tree[a] = raznost[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a * 2, tl, tm);
        build(a * 2 + 1, tm + 1, tr);
        tree[a] = tree[a * 2] + tree[a * 2 + 1];
    }
}

void update(int l, int r, int c, int tl, int tr) {
    raznost[l - 1] += c;
    raznost[r] -= c;
    build(1, tl, tr);  // грубо перестраиваю все дерево, а не только то, что надо
    /*
    // не одолел правильный апдейт
    if (tl == tr) {
        if (tl == l) {
            tree[l] += c;
        } else {
            if (tr == r + 1) {
                tree[r + 1] -= c;
            }
        }
    } else {
        int tm = (tl + tr) / 2;
        update(a * 2, tl, tm);
        update(a * 2 + 1, tm + 1, tr);
        tree[a] = tree[a * 2] + tree[a * 2 + 1];
    }
    */
}

int summ(int a, int tl, int tr, int l, int r) {
    if (r < tl || l > tr)
        return 0;
    if (l <= tl && tr <= r)
        return tree[a];
    int tm = (tl + tr) / 2;
    return summ(a * 2, tl, tm, l, r) + summ(a * 2 + 1, tm + 1, tr, l, r);
}

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    int n, k, a, b, c, otv;
    char t;
    std::cin >> n;

    // стоило раскладывать сразу с индекса 1?
    for (int i = 0; i < n; i++) {
        std::cin >> v[i];
    }

    // по-моему, не нужный кусок
    for (int i = 0; i < n; i++) {
        raznost[i] = v[i];
    }

    // создаем разностный массив
    raznost[0] = v[0];
    for (int i = 1; i < n; i++) {
        raznost[i] = v[i] - v[i - 1];
    }

    build(1, 0, n - 1);  // строим дерево

    // выполняем k запросов
    std::cin >> k;
    for (int i = 0; i < k; i++) {
        std::cin >> t;
        if (t == 'g') {
            // запрос числа на b-м месте
            std::cin >> b;
            otv = summ(1, 0, n - 1, 1 - 1, b - 1); // сумма от первого элемента до i-го и есть искомое
            std::cout << otv << '\n';
        } else {
            // добавление числа c на отрезке [a, b]
            std::cin >> a >> b >> c;
            update(a, b, c, 0, n - 1);
        }
    }

/*
5
7 3 1 6 4
5
g 5
g 4
g 3
a 2 4 4
g 4

4
6
1
10
*/
}


-- Знакопеременная сумма на отрезке
-- ошибка выполнения на 9-м
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> v(10000), tree(400000, 0);

void build(int a, int tl, int tr) {
    if (tl == tr) {
        tree[a] = v[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a * 2, tl, tm);
        build(a * 2 + 1, tm + 1, tr);
        tree[a] = tree[a * 2] + tree[a * 2 + 1];
    }
}

void update(int a, int b, int tl, int tr) {
    v[a] = b;
    build(1, tl, tr);  // неправильно грубо перестраиваю дерево отрезков каждый раз
}

int summ(int a, int tl, int tr, int l, int r) {
    if (r < tl || l > tr)
        return 0;
    if (l <= tl && tr <= r)
        return tree[a];
    int tm = (tl + tr) / 2;
    return summ(a * 2, tl, tm, l, r) + summ(a * 2 + 1, tm + 1, tr, l, r);
}

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    int n, k, a, b, c, otv;
    std::cin >> n;

    // ввод исходных данных, умножая каждый четный элемент на -1
    for (int i = 0; i < n; i++) {
        if (i % 2 == 0) {
            std::cin >> v[i];
        } else {
            std::cin >> c;
            v[i] = -1 * c;
        }
    }

    build(1, 0, n - 1);

    // выполняем запросы
    // если меняем четный элемент, не забывать на -1 умножить
    // и если сумма элементов, начиная с четного элемента, то умножаем полученное на -1
    std::cin >> k;
    for (int i = 0; i < k; i++) {
        std::cin >> c;
        if (c == 1) {
            std::cin >> a >> b;
            otv = summ(1, 0, n - 1, a - 1, b - 1);
            if (a % 2 == 1) {
                std::cout << otv << '\n';
            } else {
                std::cout << -1 * otv << '\n';
            }
        } else {
            std::cin >> a >> b;
            if (a % 2 == 1) {
                update(a - 1, b, 0, n - 1);
            } else {
                update(a - 1, -1 * b, 0, n - 1);
            }
        }
    }
}

-- вариант с попыткой правильного апдейта
-- неправильный ответ уже на третьем тесте
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> v(10000), tree(400000, 0);

void build(int a, int tl, int tr) {
    if (tl == tr) {
        tree[a] = v[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a * 2, tl, tm);
        build(a * 2 + 1, tm + 1, tr);
        tree[a] = tree[a * 2] + tree[a * 2 + 1];
    }
}

void update(int a, int b, int c, int tl, int tr) {
    // попытка сделать правильный вариант апдейта
    if (tl == tr) {
        tree[a] = c;
    } else {
        int tm = (tl + tr) / 2;
        if (b <= tm) {
            update (a * 2, b, c, tl, tm);
        } else {
            update (a * 2 + 1, b, c, tm + 1, tr);
        }
        tree[a] = tree[a * 2] + tree[a * 2 + 1];
    }
}

int summ(int a, int tl, int tr, int l, int r) {
    if (r < tl || l > tr)
        return 0;
    if (l <= tl && tr <= r)
        return tree[a];
    int tm = (tl + tr) / 2;
    return summ(a * 2, tl, tm, l, r) + summ(a * 2 + 1, tm + 1, tr, l, r);
}

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    int n, k, a, b, c, otv;
    std::cin >> n;

    for (int i = 0; i < n; i++) {
        if (i % 2 == 0) {
            std::cin >> v[i];
        } else {
            std::cin >> c;
            v[i] = -1 * c;
        }
    }

    build(1, 0, n - 1);

    // выполняем запросы
    std::cin >> k;
    for (int i = 0; i < k; i++) {
        std::cin >> c;
        if (c == 1) {
            std::cin >> a >> b;
            otv = summ(1, 0, n - 1, a - 1, b - 1);
            if (a % 2 == 1) {
                std::cout << otv << '\n';
            } else {
                std::cout << -1 * otv << '\n';
            }
        } else {
            std::cin >> a >> b;
            if (a % 2 == 1) {
                update(a - 1, a - 1, b, 0, n - 1);
            } else {
                update(a - 1, a - 1, -1 * b, 0, n - 1);
            }
        }
    }
}



-- Количество путей между компонентами сильной связности
#include <iostream>
#include <vector>
#include <algorithm>

void TopSort(int x, std::vector<int>& color, std::vector<std::vector<int>>& smezh,
         int rod, std::vector<int>& topsort) {
    color[x] = -1;
    for (int i = 0; i < smezh[x].size(); i++) {
        if (color[smezh[x][i]] == 0) {
            TopSort(smezh[x][i], color, smezh, x, topsort);
        }
    }
    topsort.push_back(x);
}

void DFS(int x, std::vector<int>& topsort, std::vector<std::vector<int>>& smezh,
         int a, std::vector<int>& color, std::vector<int>& used) {
    used[x] = -1;
    color[x] = a;
    // std::cout << "x " << x + 1 << ' ' << a << '\n';
    for (int i = 0; i < smezh[x].size(); i++) {
        if (used[smezh[x][i]] != -1) {
            DFS(smezh[x][i], topsort, smezh, a, color, used);
            // std::cout << 1;
        }
    }
}

int main() {
    int n, m, a, b;
    std::cin >> n >> m;
    std::vector<std::vector<int>> v(m, std::vector<int>(2)), smezh(n), antismezh(n);  // ребра, топсорт
    std::vector<int> color(n), topsort, used(n);  // посещенные вершины, ответ

    // вводим данные
    for (int i = 0; i < m; i++) {
        std::cin >> a >> b;
        v[i][0] = a - 1;
        v[i][1] = b - 1;
    }

    // создаем списки смежности для прямого и обратного графа
    for (int i = 0; i < m; i++) {
        smezh[v[i][0]].push_back(v[i][1]);
        antismezh[v[i][1]].push_back(v[i][0]);
    }

    // "топсорт" для обратного графа
    for (int i = 0; i < n; i++) {
        if (color[i] == 0) {
            TopSort(i, color, antismezh, n, topsort);
        }
    }
    std::reverse(topsort.begin(), topsort.end());
    /*
    std::cout << "topsort ";
    for (auto i: topsort) {
        std::cout << i + 1 << ' ';
    }
    std::cout << '\n';
    */

    // покраска ксс
    a = 0;
    for (int i = 0; i < n; i++) {
        if(used[topsort[i]] != -1) {
            DFS(topsort[i], topsort, smezh, a, color, used);
            // std::cout << '\n';
            a += 1;
        }
    }
    /*
    std::cout << "color ";
    for (auto i: u) {
        std::cout << i << ' ';
    }
    std::cout << '\n';
    */

    a = 0;
    for (int i = 0; i < m; i++) {
        if (color[v[i][0]] != color[v[i][1]]) {
            // std::cout << v[i][0] + 1 << ' ' << v[i][1] + 1 << '\n';
            a += 1;
        }
    }
    std::cout << a;
}

/*

? 0
4 5
1 2
2 3
3 1
2 4
3 4

2 треугольника несвязных 0
6 6
1 2
2 3
3 1
4 5
5 6
6 4

треугольник и отдельная 1
4 4
1 2
2 3
3 1
2 4

бамбук 2
3 2
1 2
2 3

цикл 0
3 3
1 2
2 3
3 1

точки 0
90 0
*/


-- Дерево отрезков с массовыми операциями
-- добавление числа на отрезке и сумма на отрезке
// не проходит тест 4
// перед каждым шагом вниз проталкиваем несогласованности вниз

#include <iostream>
#include <vector>

using namespace std;

const long long N = 150000 + 7;
const long long NO_OPERATION = 0;
vector <long long> input(N, NO_OPERATION);  // вектор исходных данных
vector <long long> tree(4 * N, NO_OPERATION);  // дерево отрезков
vector <long long> shift(4 * N, NO_OPERATION);  // вектор несогласованных модификаций


void build_tree(long long vertex, long long tl, long long tr) {
    /* строим изначальное дерево */

    if (tl == tr) {
        // листья
        tree[vertex] = input[tl];
    } else {
        long long tm = (tl + tr) / 2;
        build_tree(vertex * 2, tl, tm);
        build_tree(vertex * 2 + 1, tm + 1, tr);
        tree[vertex] = tree[vertex * 2] + tree[vertex * 2 + 1];
    }
}


void push(long long vertex, long long tl, long long tr) {
    /* проталкиваем несогласованные модификации вниз */

    if (shift[vertex] != NO_OPERATION && vertex * 2 + 1 < 4 * N) {  // если есть что и куда проталкивать

        // вниз проталкиваем несогласованность - в детей, обнуляем в родителе
        shift[vertex * 2] += shift[vertex];
        shift[vertex * 2 + 1] += shift[vertex];
        shift[vertex] = NO_OPERATION;

        // пересчитываем в детях значения tree
        long long tm = (tl + tr) / 2;
        tree[vertex * 2] += (tm - tl + 1) * shift[vertex * 2];
        tree[vertex * 2 + 1] += (tr - tm) * shift[vertex * 2 + 1];
    }
}


long long get_sum(long long l, long long r, long long vertex, long long tl, long long tr) {
    /* получаем сумму на отрезке */

    // поддерево внутри интервала модификации
    if (l <= tl && tr <= r) {
        return tree[vertex];
    }

    // поддерево вне интервала
    if (tr < l || r < tl) {
        return 0;
    }

    // поддерево пересекается с интервалом частично
    push(vertex, tl, tr);    // перед каждым шагом вниз проталкиваем несогласованности вниз
    long long tm = (tl + tr) / 2;
    return get_sum(l, r, vertex * 2, tl, tm) + get_sum(l, r, vertex * 2 + 1, tm + 1, tr);
}


void add(long long l, long long r, long long val, long long vertex, long long tl, long long tr) {
    /* update на отрезке */

    // поддерево внутри интервала модификации. Изменяем сумму и запоминаем несогласованность
    if (l <= tl && tr <= r) {
        tree[vertex] += val * (tr - tl + 1);
        shift[vertex] += val;
        return;
    }

    // поддерево вне интервала. Ничего не делаем
    if (tr < l || r < tl) {
        return;
    }

    // поддерево пересекается с интервалом частично.
    // перед каждым шагом вниз проталкиваем несогласованности вниз
    push(vertex, tl, tr);
    // шагаем в левого сына, потом в правого
    long long tm = (tl + tr) / 2;
    add(l, r, val, vertex * 2,     tl,     tm);
    add(l, r, val, vertex * 2 + 1, tm + 1, tr);
    // считаем значение в вершине после того, как сыновей отработали
    tree[vertex] = tree[vertex * 2] + tree[vertex * 2 + 1];
}


void print(vector <long long> & vec) {
    /* печать массивов для дебага */

    for (auto i: vec) {
        cout << i << ' ';
    }
    cout << '\n';
}


int main() {
    // #define int long long
    long long n, a, b, c, m;
    string str;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> input[i];
    }
    build_tree(1, 0, n - 1);
    // print(tree);
    // print(shift);
    // cout << '\n';
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> str >> a >> b;
        if (str == "add") {
            cin >> c;
            add(a - 1, b - 1, c, 1, 0, n - 1);
            // print(tree);
            // print(shift);
            // cout << '\n';
        } else {
            cout << get_sum(a - 1, b - 1, 1, 0, n - 1) << '\n';
            // print(tree);
            // print(shift);
            // cout << '\n';
        }
    }
}

/*
10
1 4 -6 5 2 -6 5 7 -1 1
11
add 1 4 -2
add 2 4 -4
sum 4 10
sum 7 9
add 6 10 -2
sum 1 6
add 1 9 -6
add 7 8 0
add 4 4 6
add 1 3 5
sum 1 10
*/



-- Дерево отрезков с массовыми операциями вариант 2
-- добавление числа на отрезке и сумма на отрезке
// не проходит тест 4
// а где мы шифты к дереву прибавляем?
// перед каждым шагом вниз проталкиваем несогласованности вниз

#include <iostream>
#include <vector>

using namespace std;


const long long N = 150000 + 7;
const long long NO_OPERATION = 0;
vector <long long> input(N);  // вектор исходных данных
vector <long long> tree(4 * N, NO_OPERATION);  // дерево отрезков
vector <long long> shift(4 * N, NO_OPERATION);  // вектор несогласованных модификаций


void build_tree(long long vertex, long long tl, long long tr) {
    /* строим изначальное дерево */

    if (tl == tr) {
        // листья
        tree[vertex] = input[tl];
    } else {
        long long tm = (tl + tr) / 2;
        build_tree(vertex * 2, tl, tm);
        build_tree(vertex * 2 + 1, tm + 1, tr);
        tree[vertex] = tree[vertex * 2] + tree[vertex * 2 + 1];
    }
}


void push(long long vertex, long long tl, long long tr) {
    /* проталкиваем несогласованные модификации вниз */

    if (shift[vertex] == NO_OPERATION) return;
    tree[vertex] += shift[vertex] * (tr - tl + 1);
    if (tr - tl != 1) {
        shift[2 * vertex] += shift[vertex];
        shift[2 * vertex + 1] += shift[vertex];
        shift[vertex] = NO_OPERATION;
    }
}


void add(long long l, long long r, long long val, long long vertex, long long tl, long long tr) {
    /* update на отрезке */

    push(vertex, tr, tl);

    // поддерево внутри интервала модификации. Изменяем сумму и запоминаем несогласованность
    if (l <= tl && tr <= r) {
        shift[vertex] = val;
        push(vertex, tr, tl);
        return;
    }

    // поддерево вне интервала. Ничего не делаем
    if (tr < l || r < tl) {
        return;
    }

    // поддерево пересекается с интервалом частично.
    long long tm = (tl + tr) / 2;
    add(l, r, val, vertex * 2,     tl,     tm);
    add(l, r, val, vertex * 2 + 1, tm + 1, tr);
    // считаем значение в вершине после того, как сыновей отработали
    tree[vertex] = tree[vertex * 2] + tree[vertex * 2 + 1];
}


long long get_sum(long long l, long long r, long long vertex, long long tl, long long tr) {
    /* получаем сумму на отрезке */

    push(vertex, tr, tl);

    // поддерево внутри интервала модификации
    if (l <= tl && tr <= r) {
        return tree[vertex];
    }

    // поддерево вне интервала
    if (tr < l || r < tl) {
        return 0;
    }

    // поддерево пересекается с интервалом частично
    long long tm = (tl + tr) / 2;
    return get_sum(l, r, vertex * 2, tl, tm) + get_sum(l, r, vertex * 2 + 1, tm + 1, tr);
}


void print(vector <long long> & vec) {
    /* печать массивов для дебага */

    for (auto i: vec) {
        cout << i << ' ';
    }
    cout << '\n';
}


int main() {
    // #define int long long
    long long n, a, b, c, m;
    string str;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> input[i];
    }
    build_tree(1, 0, n - 1);
    // print(tree);
    // print(shift);
    // cout << '\n';
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> str >> a >> b;
        if (str == "add") {
            cin >> c;
            add(a - 1, b - 1, c, 1, 0, n - 1);
            // print(tree);
            // print(shift);
            // cout << '\n';
        } else {
            cout << get_sum(a - 1, b - 1, 1, 0, n - 1) << '\n';
            // print(tree);
            // print(shift);
            // cout << '\n';
        }
    }
}

/*
10
1 4 -6 5 2 -6 5 7 -1 1
10
add 1 4 -2
add 2 4 -4
sum 4 10
sum 7 9
add 6 10 -2
sum 1 6
add 1 9 -6
add 7 8 0
add 4 4 6
add 1 3 5
*/


-- Дерево отрезков с массовыми операциями
-- присвоение на отрезке и минимум на отрезке
// не проходит тест 4

// перед каждым шагом вниз проталкиваем несогласованности вниз

#include <iostream>
#include <vector>

using namespace std;

const long long N = 150000 + 7;
const long long NO_OPERATION = 1e9 + 7;
vector <long long> input(N, NO_OPERATION);  // вектор исходных данных
vector <long long> tree(4 * N, NO_OPERATION);  // дерево отрезков
vector <long long> shift(4 * N, NO_OPERATION);  // вектор несогласованных модификаций


void build_tree(long long vertex, long long tl, long long tr) {
    /* строим изначальное дерево */

    if (tl == tr) {
        // листья
        tree[vertex] = input[tl];
    } else {
        long long tm = (tl + tr) / 2;
        build_tree(vertex * 2, tl, tm);
        build_tree(vertex * 2 + 1, tm + 1, tr);
        tree[vertex] = min(tree[vertex * 2], tree[vertex * 2 + 1]);
    }
}


void push(long long vertex, long long tl, long long tr) {
    /* проталкиваем несогласованные модификации вниз */

    if (shift[vertex] != NO_OPERATION && vertex * 2 + 1 < 4 * N) {  // если есть что и куда проталкивать

        // вниз проталкиваем несогласованность - в детей, "обнуляем" в родителе
        shift[vertex * 2] = shift[vertex];
        shift[vertex * 2 + 1] = shift[vertex];
        shift[vertex] = NO_OPERATION;

        // пересчитываем в детях значения tree
        long long tm = (tl + tr) / 2;
        tree[vertex * 2] = min(tree[vertex * 2], shift[vertex * 2]);
        tree[vertex * 2 + 1] = min(tree[vertex * 2 + 1], shift[vertex * 2 + 1]);
    }
}


long long get_min(long long l, long long r, long long vertex, long long tl, long long tr) {
    /* получаем минимум на отрезке */

    // поддерево внутри интервала
    if (l <= tl && tr <= r) {
        return tree[vertex];
    }

    // поддерево вне интервала
    if (tr < l || r < tl) {
        return NO_OPERATION;
    }

    // поддерево пересекается с интервалом частично
    push(vertex, tl, tr);  // перед каждым шагом вниз проталкиваем несогласованности вниз
    long long tm = (tl + tr) / 2;
    return min(get_min(l, r, vertex * 2, tl, tm), get_min(l, r, vertex * 2 + 1, tm + 1, tr));
}


void ass(long long l, long long r, long long val, long long vertex, long long tl, long long tr) {
    /* update на отрезке */

    // поддерево внутри интервала присвоения значения. Изменяем значение и запоминаем несогласованность
    if (l <= tl && tr <= r) {
        shift[vertex] = val;
        tree[vertex] = val;
        return;
    }

    // поддерево вне интервала. Ничего не делаем
    if (tr < l || r < tl) {
        return;
    }

    // поддерево пересекается с интервалом частично.
    // перед каждым шагом вниз проталкиваем несогласованности вниз
    push(vertex, tl, tr);
    // шагаем в левого сына, потом в правого
    long long tm = (tl + tr) / 2;
    ass(l, r, val, vertex * 2,     tl,     tm);
    ass(l, r, val, vertex * 2 + 1, tm + 1, tr);
    // считаем значение в вершине после того, как сыновей отработали
    tree[vertex] = min(tree[vertex * 2], tree[vertex * 2 + 1]);
}


void print(vector <long long> & vec) {
    /* печать массивов для дебага */

    for (auto i: vec) {
        cout << i << ' ';
    }
    cout << '\n';
}


int main() {
    // #define int long long
    long long n, a, b, c, m;
    string str;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> input[i];
    }
    build_tree(1, 0, n - 1);
    // print(tree);
    // print(shift);
    // cout << '\n';
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> str >> a >> b;
        if (str == "set") {
            cin >> c;
            ass(a - 1, b - 1, c, 1, 0, n - 1);
            // print(tree);
            // print(shift);
            // cout << '\n';
        } else {
            cout << get_min(a - 1, b - 1, 1, 0, n - 1) << '\n';
            // print(tree);
            // print(shift);
            // cout << '\n';
        }
    }
}


-- Дерево отрезков с массовыми операциями вариант 3
-- добавление числа на отрезке и сумма на отрезке

// В этом коде относительно редкий вариант?
// Перед каждым шагом вниз проталкиваем несогласованности вниз,
// пересчитываем истинное значение в детях, "обнуляем" несогласованность в родителе.
// В других решениях чаще, кажется, пересчет значений делается только при запросе значения

#include <iostream>
#include <vector>

using namespace std;

const long long N = 150000 + 7;
const long long NO_OPERATION = 0;
vector <long long> input(    N, NO_OPERATION);  // вектор исходных данных
vector <long long>  tree(4 * N, NO_OPERATION);  // дерево отрезков
vector <long long> shift(4 * N, NO_OPERATION);  // вектор несогласованных модификаций
// в данном коде несогласованность - это несогласованность с детьми,
// сами значения для детей в tree мы пересчитываем сразу после проталкивания и они "согласованны"


void build_tree(long long vertex, long long tl, long long tr) {
    /* строим изначальное дерево */

    if (tl == tr) {
        // листья
        tree[vertex] = input[tl];
    } else {
        // рекурсивно строим дерево
        long long tm = (tl + tr) / 2;
        build_tree(vertex * 2,         tl, tm);
        build_tree(vertex * 2 + 1, tm + 1, tr);
        tree[vertex] = tree[vertex * 2]
                     + tree[vertex * 2 + 1];
    }
}


void push(long long vertex, long long tl, long long tr) {
    /* проталкиваем несогласованные модификации вниз */

    if (shift[vertex] == NO_OPERATION) return;

    // если мы не в листе
    if (tr - tl != 0) {
        // вниз проталкиваем несогласованность - в детей.
        // Если там уже была несогласованность, то надо добавить к ней.
        shift[vertex * 2]     += shift[vertex];
        shift[vertex * 2 + 1] += shift[vertex];

        // пересчитываем в детях значения tree
        long long tm = (tl + tr) / 2;
        tree[vertex * 2]     += (tm - tl + 1) * shift[vertex];
        tree[vertex * 2 + 1] += (tr - tm)     * shift[vertex];

        // несогласованности с детьми в родителе теперь нет
        shift[vertex] = NO_OPERATION;
        return;
    }
}


void add(long long l, long long r, long long val, long long vertex, long long tl, long long tr) {
    /* update на отрезке */

    // поддерево вне интервала. Ничего не делаем
    if (tr < l || r < tl) {
        return;
    }

    // поддерево внутри интервала модификации. Изменяем сумму в tree и запоминаем несогласованность
    if (l <= tl && tr <= r) {
        tree[vertex]  += val * (tr - tl + 1);
        shift[vertex] += val;
        return;
    }

    // поддерево пересекается с интервалом частично.
    push(vertex, tl, tr);  // перед каждым шагом вниз проталкиваем несогласованности вниз
    // шагаем в левого сына, потом в правого
    long long tm = (tl + tr) / 2;
    add(l, r, val, vertex * 2,         tl, tm);
    add(l, r, val, vertex * 2 + 1, tm + 1, tr);
    // считаем значение в вершине после того, как сыновей отработали
    tree[vertex] = tree[vertex * 2]
                 + tree[vertex * 2 + 1];
}


long long get_sum(long long l, long long r, long long vertex, long long tl, long long tr) {
    /* получаем сумму на отрезке */

    // поддерево вне интервала
    if (tr < l || r < tl) {
        return NO_OPERATION;
    }

    // поддерево внутри интервала модификации
    if (l <= tl && tr <= r) {
        return tree[vertex];
    }

    // поддерево пересекается с интервалом частично
    push(vertex, tl, tr);    // перед каждым шагом вниз проталкиваем несогласованности вниз
    long long tm = (tl + tr) / 2;
    return get_sum(l, r, vertex * 2,         tl, tm)
         + get_sum(l, r, vertex * 2 + 1, tm + 1, tr);
}


void print(vector <long long> & vec) {
    /* печать массивов для дебага */

    for (auto i: vec) {
        cout << i << ' ';
    }
    cout << '\n';
}


int main() {
    long long n, a, b, c, m;
    string str;

    // строим дерево
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> input[i];
    }
    build_tree(1, 0, n - 1);
    // print(tree);
    // print(shift);
    // cout << '\n';

    // исполняем запросы
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> str >> a >> b;
        if (str == "add") {
            cin >> c;
            add(a - 1, b - 1, c, 1, 0, n - 1);
            // print(tree);
            // print(shift);
            // cout << '\n';
        } else {
            cout << get_sum(a - 1, b - 1, 1, 0, n - 1) << '\n';
            // print(tree);
            // print(shift);
            // cout << '\n';
        }
    }
}

/*
10
1 4 -6 5 2 -6 5 7 -1 1
11
add 1 4 -2
add 2 4 -4
sum 4 10
sum 7 9
add 6 10 -2
sum 1 6
add 1 9 -6
add 7 8 0
add 4 4 6
add 1 3 5
sum 1 10

10
1 4 -6 5 2 -6 5 7 -1 1
15
add 1 4 -2
add 2 4 -4
sum 4 10
sum 7 9
add 6 10 -2
sum 1 6
sum 1 10
add 1 9 -6
sum 1 10
add 7 8 0
sum 1 10
add 4 4 6
sum 1 10
add 1 3 5
sum 1 10

*/


--LCA
#include <iostream>
#include <vector>
#include <algorithm>

long long t = 0, Logn = 1;

// создание вектора предподсчета родителей 2^i и векторов tin и tout
void DFS(long long v,
            std::vector<std::vector<long long>>& up,
            std::vector<long long>& tin,
            std::vector<long long>& tout,
            std::vector<std::vector<long long>>& V,
            std::vector<long long>& Rod) {
    for (int i = 1; i < Logn; i++)
        up[v][i] = up[up[v][i - 1]][i - 1];
    tin[v] = t++;
    for (int u : V[v]) {
        up[u][0] = v;
        // if (u != Rod[v]) {}
        DFS(u, up, tin, tout, V, Rod);
    }
    tout[v] = t++;
}

// является ли одна вершина предком другой
bool ancestor(long long u,
                long long v,
                std::vector<long long>& tin,
                std::vector<long long>& tout) {
    return tin[u] <= tin[v] && tout[v] <= tout[u];
}

// нахождение ближайшего общего предка
int lca(long long v,
        long long u,
        std::vector<long long>& tin,
        std::vector<long long>& tout,
        std::vector<std::vector<long long>>& up) {
    if (ancestor(v, u, tin, tout)) {
        return v;
    }
    if (ancestor(u, v, tin, tout)) {
        return u;
    }
    for (int l = Logn-1; l >= 0; l--) {
        if (!ancestor(up[v][l], u, tin, tout))
            v = up[v][l];
    }
    return up[v][0];
}

int main() {
    long long n, m, x, y, z, u, ob;
    long long Ans = 0;  // сумма всех наших промежуточных ответов
    std::cin >> n >> m;
    std::vector<long long> a(2 * m + 1), tin(n), tout(n), Rod(n);
    while ((1<<Logn) <= n) Logn++;
    std::vector<std::vector<long long>> V(n), up(n, std::vector<long long>(Logn));

    // нам дается родитель для каждой вершины, делаем список смежности,
    // но только детей
    Rod[0] = 0;
    for (int i = 1; i < n; i++) {
        std::cin >> Rod[i];
        // V[i].push_back(Rod[i]);
        V[Rod[i]].push_back(i);
    }

    std::cin >> a[1] >> a[2];
    std::cin >> x >> y >> z;

    // генерация какого-то вектора, на основании которого мы потом будем генерировать запросы
    for (int i = 3; i <= 2 * m; i++) {
        a[i] = (x * a[i - 2] + y * a[i - 1] + z) % n;
        // std::cout << i << ' ' << a[i] << '\n';
    }

    DFS(0, up, tin, tout, V, Rod);
    for (auto i: up) {
        for (auto j: i) {
            std::cout << j << ' ';
        }
        std::cout << '\n';
    }
    ob = lca(a[1], a[2], tin, tout, up);
    Ans += ob;
    // std::cout << ob << '\n';
    for (int i = 2; i <= m; i++) {
        // следующую пару вершин для запроса генерируем во по такой формуле
        std::cout << "i-" << i << " v-" << (a[i * 2 - 1] + ob) % n << " u-" << a[i * 2];
        ob = lca((a[i * 2 - 1] + ob) % n, a[i * 2], tin, tout, up);
        Ans += ob;
        std::cout << " ob-" << ob << " Ans-" << Ans << '\n';
        // std::cout << ob << '\n';
    }
    std::cout << Ans;
    return 0;
}

/*
3 2
0 1
2 1
1 1 0
ответ 2

1 2

0 0
1 1 1
ответ 0

3 1
0 1
2 1
1 1 0
ответ 1

10 10
6 7 7 8 8 9 9 0 0
4 6
876543 987654 654321


13 10
6 7 7 8 8 9 9 0 0 1 10 11
12 9
942381 989859 579345

*/